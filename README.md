# Agenda 
 In this tutorial, you will work with an application containing RTL and OpenCL kernels to familizarize SDAccel flow and  Various Design Analysis features.

## Application Overview

This tutorial contains four simple kernels:

1. One RTL Kernel:KVConstAdd
2. Three OpenCL Kernel: KA,KB,KCalc

Let's review each kernel

The KVConstAdd is a simple RTL kernel which adds a constant '1' to the input Vector as shown in the following figure. In here, s_axis_tdata is the input vector of type AXIS and a constant_in - 1 is added to the vector.

![image](https://user-images.githubusercontent.com/32319498/45986727-22332b80-c022-11e8-9946-ad44fcef1c66.png)

The KA Kernel scnas the data_1 vector and calculates a single BUF_KA cell using four data_1 cells.

![image](https://user-images.githubusercontent.com/32319498/45986879-11cf8080-c023-11e8-9fd6-0f41d91eefba.png)

The KB kernel has a similar structure 

![image](https://user-images.githubusercontent.com/32319498/45986929-6b37af80-c023-11e8-8e48-fcb4cde14a13.png)

The Kcalc reads the data from the KA and KB and calculates a result which is written into the Result Buffer.

![image](https://user-images.githubusercontent.com/32319498/45986953-9c17e480-c023-11e8-968d-01620018bdf7.png)

The Application block diagram is shown in the below figure.

![image](https://user-images.githubusercontent.com/32319498/45986984-dda88f80-c023-11e8-8315-ea50b54c25db.png)

A host automatically generates and delivers two input arrays DataIn_1 and DataIn_2 (each contains 4096 integer values) from the Host to the Global Memory (DDR). The application processes these two arrays and generates output results RES (1024 integer values). At the beginning DataIn_1 is processed and updated by the KVConstAdd kernel. When KVConstAdd completes its work, KA reads DataIn_1 and generates intermediate results, which are stored in the BUF_KA array (1024
integer values), located in the Global Memory. At the same time KB processes DataIn_2 and generates intermediate results,
which are stored in BUF_KB (1024 integer values). When KA and KB are completed their work, KCalc processes BUF_KA and BUF_KB and generates final results RES (1024 integer values). At the end, the host transfers the final results RES from the Global to Host Memory and checks their correctness. The overall application structure is represented on the following figure:

![image](https://user-images.githubusercontent.com/32319498/45987018-15afd280-c024-11e8-8fbc-8600422fdc73.png)

###The Host has 3 input arguments:
	Platform – the name of the Platform Vendor.
	In our case this is Xilinx
	 Device – the target OpenCL device.
	For this tutorial you will use ....(add here)
 	XCLBIN – the name of the Xilinx binary container where the kernels are precompiled.

The application creates the RES.txt output file containing the results generated by the application.

## SDx Setup

1. Launch SDx Environment.
2. Launch SDAccel in GUI mode create a Application project with an empty application.
3. Import the source files from the sources directory by right clicking on the src and selecting the import option.
4. In the Select dialog box expand the "general" category and select the "File System" and press next.Browse the sources and import the following files 

###FILES
	1. help_functions.cpp
	2. help_functions.h
	3. host_1.cpp
	4. K_OpenCL_1.cl
	5. kernel.h
	6. KVConstAdd.xo

the following steps needs to be foloowed for compiling the application.

1. you need to create a binary container where SDAccel will compile kernels.
2. Add the KVCOnstAdd, KA,KB,KcalC Kernels to hte binary container.

After perfoming the above steps, the project window should look like similar to the below figure:

![image](https://user-images.githubusercontent.com/32319498/45987632-7db3e800-c027-11e8-8a14-118643a27f8f.png)

Now The project is ready to be compiled.

## SW Emulation: Compile / Run. Results Overview

SW emulation validates the functional correctness of the design adn to partition the application into kernels. Select the build to be Emulation-SW and build the design. After it is build, in the run configurations, Argument tab specify the following commadn line options and run the design:

**Xilinx xilinx_u200_xdma_201820_1 ../binary_container_1.xclbin**

The application was successfully run and genrated RES.txt file. This file can be found in the RTL_OPENCL_KERNEL-Default direcoty. 

By default, SW Emulation does not generate reports. But, if needed this option is avaialble in the Project window: Report Type - Estimate. This generates 3 reports .
	1. Profile Summary
	2. Application Timeline.
	3. System Estimate
	4. HLS Synthesis reports

These can be viewed in the Assistant Window, Software Emulation 

## PICTURE HER 


The Profile Summary contains a number of statistical data collected during the application run(host and kernels).

![s_p](https://user-images.githubusercontent.com/32319498/45988369-6c6cda80-c02b-11e8-8d3d-56fa1f36c721.PNG)


However, as you can see, at the SW Emulation step several pieces of information are still missing in the Data Transfer area (for example between Kernels and Global Memory). This information will be available at the HW
Emulation step and after System Run.

The Application TimeLine report represents execution of the different application parts using time axe

EDIT NEEDED EHRE

![image](https://user-images.githubusercontent.com/32319498/45988421-b0f87600-c02b-11e8-810b-9ab16ac9455c.png)


As in the case of the Profile Summary report, not all data is available in Application Timeline at this step of the flow.

## HW Emulation: Compile / Run. Results Overview

While the SW Emulation flow is a good measure of functional correctness, it does not guarantee the correctness on the FPGA execution target. The Hardware Emulation flow enables checking of the correctness of the generated logic. This emulation flow invokes the hardware simulator in the SDAccel environment to test the logic functionality. As a consequence, the runtime in the Hardware Emulation flow is longer than in the SW Emulation flow.

In addition HW Emulation flow provides more complete and precise profiling information allowing the user to analyze the application performance and identify the bottlenecks.

Select teh build configuration to be Emulation-HW and build and run the design.

After the application exectuion is successfully completed, we shpould see hte following log messages

![image](https://user-images.githubusercontent.com/32319498/45988847-d8504280-c02d-11e8-9889-698ceefb5536.png)


If you expand the HW Emulation tab in the assistant window, you will see SDAccel generates various reports as shown in the below figure.

![image](https://user-images.githubusercontent.com/32319498/45988884-0170d300-c02e-11e8-9d5d-6816632ee6b9.png)


Open the **Profile Summary** report.

![h_p](https://user-images.githubusercontent.com/32319498/45989083-d63ab380-c02e-11e8-9faa-634407ce3877.PNG)


You will see that information related to Data Transfer and missing at the SW emulation step is available here. On this page we can see that HW Emulation flow estimated for example for KA  kernel duration as 0.011 ms. The same info can be also found on the “Kernels & Compute Units” tab.

In addition the system automatically analyses the performance of your application and suggests areas for improvements. This is available in the **GUIDANCE** tab. Review the GUIDANCE and investigate different type of provided
information and Suggestions from SDAccel on how to improve the performance.

![image](https://user-images.githubusercontent.com/32319498/45988977-793efd80-c02e-11e8-91ca-eb50bfb0c9a5.png)

Open the **Application Timeline** view.

The Application Timeline view also contains data transfer information which was missing at the SW Emulation step. Using markers you can for example measure time spent by application (execution of four kernels) to process input data and
generate final results - it is ~26,000 ms

![h_a](https://user-images.githubusercontent.com/32319498/45989230-9d4f0e80-c02f-11e8-8d90-5ba4ed2499b7.PNG)

Open The **System Estimate** report

The System Estimate report provides information on every binary container in the application and every compute unit in the design, such as Timing information, Latency information, and Area to be used by a compute unit on the target device.

![image](https://user-images.githubusercontent.com/32319498/45989309-0a62a400-c030-11e8-8e99-c2af9ecf0ea4.png)

**Open the HLS Report (example: KA)**
The HLS Report contains various information generated by Vivado HLS, which is very helpful for detailed kernel performance/area analysis

![image](https://user-images.githubusercontent.com/32319498/45989349-354cf800-c030-11e8-9186-2538024567ab.png)

**HLS DRCS (example: KA)**

In addition to HLS Report, SDAccel collects various DRC messages generated by HLS Synthesis and presents them in a form of guidance messagesfor each kernel which are reported in the GUIDANCE TAB. THis information is very helpful for detailed kernel analysis.

![image](https://user-images.githubusercontent.com/32319498/45989416-7cd38400-c030-11e8-9126-75f62b39ba5e.png)

## System Run: Review HW Deployment Results

